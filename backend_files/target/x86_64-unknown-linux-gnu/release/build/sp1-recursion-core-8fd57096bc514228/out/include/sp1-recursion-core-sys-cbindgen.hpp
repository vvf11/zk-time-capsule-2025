#pragma once

/* Automatically generated by `cbindgen`. Not intended for manual editing. */

#include <cstdint>
#include <cstddef>

namespace sp1_recursion_core_sys {

constexpr static const uintptr_t PV_DIGEST_NUM_WORDS = 8;

/// The number of different range check operations.
constexpr static const uintptr_t NUM_RANGE_CHECK_OPS = 2;

constexpr static const uintptr_t NUM_BASE_ALU_ENTRIES_PER_ROW = 4;

constexpr static const uintptr_t NUM_EXT_ALU_ENTRIES_PER_ROW = 4;

constexpr static const uintptr_t NUM_CONST_MEM_ENTRIES_PER_ROW = 2;

constexpr static const uintptr_t NUM_VAR_MEM_ENTRIES_PER_ROW = 2;

/// The width of the permutation.
constexpr static const uintptr_t WIDTH = 16;

constexpr static const uintptr_t RATE = (WIDTH / 2);

constexpr static const uintptr_t NUM_EXTERNAL_ROUNDS = 8;

constexpr static const uintptr_t NUM_INTERNAL_ROUNDS = 13;

constexpr static const uintptr_t NUM_ROUNDS = (NUM_EXTERNAL_ROUNDS + NUM_INTERNAL_ROUNDS);

constexpr static const uintptr_t NUM_INTERNAL_ROUNDS_S0 = (NUM_INTERNAL_ROUNDS - 1);

constexpr static const uintptr_t OUTPUT_ROUND_IDX = (NUM_EXTERNAL_ROUNDS + 2);

constexpr static const uintptr_t PUB_VALUES_LOG_HEIGHT = 4;

/// The heap pointer address.
constexpr static const int32_t HEAP_PTR = -4;

constexpr static const uintptr_t STACK_SIZE = (1 << 24);

constexpr static const uintptr_t HEAP_START_ADDRESS = (STACK_SIZE + 4);

constexpr static const uintptr_t MEMORY_SIZE = (1 << 28);

/// The width of the Poseidon2 permutation.
constexpr static const uintptr_t PERMUTATION_WIDTH = 16;

constexpr static const uint64_t POSEIDON2_SBOX_DEGREE = 7;

constexpr static const uintptr_t HASH_RATE = 8;

/// The current verifier implementation assumes that we are using a 256-bit hash with 32-bit
/// elements.
constexpr static const uintptr_t DIGEST_SIZE = 8;

constexpr static const uintptr_t NUM_BITS = 31;

constexpr static const uintptr_t D = 4;

constexpr static const uintptr_t OUTER_MULTI_FIELD_CHALLENGER_WIDTH = 3;

constexpr static const uintptr_t OUTER_MULTI_FIELD_CHALLENGER_RATE = 2;

constexpr static const uintptr_t OUTER_MULTI_FIELD_CHALLENGER_DIGEST_SIZE = 1;

/// The maximum size of the memory in bytes.
constexpr static const uint32_t MAXIMUM_MEMORY_SIZE = UINT32_MAX;

/// The number of bits in a byte.
constexpr static const uintptr_t BYTE_SIZE = 8;

/// The size of a word in bytes.
constexpr static const uintptr_t WORD_SIZE = 4;

/// The number of bytes necessary to represent a 64-bit integer.
constexpr static const uintptr_t LONG_WORD_SIZE = (2 * WORD_SIZE);

/// The Baby Bear prime.
constexpr static const uint32_t BABYBEAR_PRIME = 2013265921;

/// The minimum file descriptor.
///
/// Any file descriptor must be greater than this value, otherwise the executor will panic.
///
/// This is useful for deprecating file descriptors.
constexpr static const uint32_t LOWEST_ALLOWED_FD = 10;

/// The number of field elements in the poseidon2 digest.
constexpr static const uintptr_t POSEIDON_NUM_WORDS = 8;

/// The maximum number of elements that can be stored in the public values vec.  Both SP1 and
/// recursive proofs need to pad their public values vec to this length.  This is required since the
/// recursion verification program expects the public values vec to be fixed length.
constexpr static const uintptr_t PROOF_MAX_NUM_PVS = 231;

enum class BaseAluOpcode {
  AddF,
  SubF,
  MulF,
  DivF,
};

enum class ExtAluOpcode {
  AddE,
  SubE,
  MulE,
  DivE,
};

/// The prime field `2^31 - 2^27 + 1`, a.k.a. the Baby Bear field.
using BabyBearP3 = uint32_t;

/// The inputs and outputs to an operation of the base field ALU.
template<typename V>
struct BaseAluIo {
  V out;
  V in1;
  V in2;
};

template<typename F>
struct BaseAluValueCols {
  BaseAluIo<F> vals;
};

template<typename F>
using Address = F;

/// An instruction invoking the extension field ALU.
template<typename F>
struct BaseAluInstr {
  BaseAluOpcode opcode;
  F mult;
  BaseAluIo<Address<F>> addrs;
};

template<typename F>
struct BaseAluAccessCols {
  BaseAluIo<Address<F>> addrs;
  F is_add;
  F is_sub;
  F is_mul;
  F is_div;
  F mult;
};

/// The smallest unit of memory that can be read and written to.
template<typename T>
struct Block {
  T _0[D];
};

/// The inputs and outputs to an operation of the extension field ALU.
template<typename V>
struct ExtAluIo {
  V out;
  V in1;
  V in2;
};

template<typename F>
struct ExtAluValueCols {
  ExtAluIo<Block<F>> vals;
};

/// An instruction invoking the extension field ALU.
template<typename F>
struct ExtAluInstr {
  ExtAluOpcode opcode;
  F mult;
  ExtAluIo<Address<F>> addrs;
};

template<typename F>
struct ExtAluAccessCols {
  ExtAluIo<Address<F>> addrs;
  F is_add;
  F is_sub;
  F is_mul;
  F is_div;
  F mult;
};

/// The base-field-valued vector inputs to the batch FRI operation.
template<typename V>
struct BatchFRIBaseVecIo {
  V p_at_x;
};

/// The extension-field-valued single inputs to the batch FRI operation.
template<typename V>
struct BatchFRIExtSingleIo {
  V acc;
};

/// The extension-field-valued vector inputs to the batch FRI operation.
template<typename V>
struct BatchFRIExtVecIo {
  V p_at_z;
  V alpha_pow;
};

/// The event encoding the data of a single iteration within the batch FRI operation.
/// For any given event, we are accessing a single element of the `Vec` inputs, so that the event
/// is not a type alias for `BatchFRIIo` like many of the other events.
template<typename F>
struct BatchFRIEvent {
  BatchFRIBaseVecIo<F> base_vec;
  BatchFRIExtSingleIo<Block<F>> ext_single;
  BatchFRIExtVecIo<Block<F>> ext_vec;
};

/// The main columns for a batch FRI invocation.
template<typename T>
struct BatchFRICols {
  Block<T> acc;
  Block<T> alpha_pow;
  Block<T> p_at_z;
  T p_at_x;
};

template<typename F>
struct BatchFRIInstrFFI {
  const Address<F> *base_vec_addrs_p_at_x_ptr;
  uintptr_t base_vec_addrs_p_at_x_len;
  const BatchFRIExtSingleIo<Address<F>> *ext_single_addrs;
  const Address<F> *ext_vec_addrs_p_at_z_ptr;
  uintptr_t ext_vec_addrs_p_at_z_len;
  const Address<F> *ext_vec_addrs_alpha_pow_ptr;
  uintptr_t ext_vec_addrs_alpha_pow_len;
  const F *acc_mult;
};

/// The preprocessed columns for a batch FRI invocation.
template<typename T>
struct BatchFRIPreprocessedCols {
  T is_real;
  T is_end;
  Address<T> acc_addr;
  Address<T> alpha_pow_addr;
  Address<T> p_at_z_addr;
  Address<T> p_at_x_addr;
};

template<typename F>
struct ExpReverseBitsEventFFI {
  const F *base;
  const F *exp_ptr;
  uintptr_t exp_len;
  const F *result;
};

template<typename T>
struct ExpReverseBitsLenCols {
  /// The base of the exponentiation.
  T x;
  /// The current bit of the exponent. This is read from memory.
  T current_bit;
  /// The previous accumulator squared.
  T prev_accum_squared;
  /// Is set to the value local.prev_accum_squared * local.multiplier.
  T prev_accum_squared_times_multiplier;
  /// The accumulator of the current iteration.
  T accum;
  /// The accumulator squared.
  T accum_squared;
  /// A column which equals x if `current_bit` is on, and 1 otherwise.
  T multiplier;
};

template<typename F>
struct ExpReverseBitsInstrFFI {
  const Address<F> *base;
  const Address<F> *exp_ptr;
  uintptr_t exp_len;
  const Address<F> *result;
  const F *mult;
};

/// Data describing in what manner to access a particular memory block.
template<typename F>
struct MemoryAccessColsChips {
  /// The address to access.
  Address<F> addr;
  /// The multiplicity which to read/write.
  /// "Positive" values indicate a write, and "negative" values indicate a read.
  F mult;
};

template<typename T>
struct ExpReverseBitsLenPreprocessedCols {
  MemoryAccessColsChips<T> x_mem;
  MemoryAccessColsChips<T> exponent_mem;
  MemoryAccessColsChips<T> result_mem;
  T iteration_num;
  T is_first;
  T is_last;
  T is_real;
};

/// The base-field-valued inputs to the FRI fold operation.
template<typename V>
struct FriFoldBaseIo {
  V x;
};

/// The extension-field-valued single inputs to the FRI fold operation.
template<typename V>
struct FriFoldExtSingleIo {
  V z;
  V alpha;
};

/// The extension-field-valued vector inputs to the FRI fold operation.
template<typename V>
struct FriFoldExtVecIo {
  V mat_opening;
  V ps_at_z;
  V alpha_pow_input;
  V ro_input;
  V alpha_pow_output;
  V ro_output;
};

/// The event encoding the data of a single iteration within the FRI fold operation.
/// For any given event, we are accessing a single element of the `Vec` inputs, so that the event
/// is not a type alias for `FriFoldIo` like many of the other events.
template<typename F>
struct FriFoldEvent {
  FriFoldBaseIo<F> base_single;
  FriFoldExtSingleIo<Block<F>> ext_single;
  FriFoldExtVecIo<Block<F>> ext_vec;
};

template<typename T>
struct FriFoldCols {
  Block<T> z;
  Block<T> alpha;
  T x;
  Block<T> p_at_x;
  Block<T> p_at_z;
  Block<T> alpha_pow_input;
  Block<T> ro_input;
  Block<T> alpha_pow_output;
  Block<T> ro_output;
};

template<typename F>
struct FriFoldInstrFFI {
  const FriFoldBaseIo<Address<F>> *base_single_addrs;
  const FriFoldExtSingleIo<Address<F>> *ext_single_addrs;
  const Address<F> *ext_vec_addrs_mat_opening_ptr;
  uintptr_t ext_vec_addrs_mat_opening_len;
  const Address<F> *ext_vec_addrs_ps_at_z_ptr;
  uintptr_t ext_vec_addrs_ps_at_z_len;
  const Address<F> *ext_vec_addrs_alpha_pow_input_ptr;
  uintptr_t ext_vec_addrs_alpha_pow_input_len;
  const Address<F> *ext_vec_addrs_ro_input_ptr;
  uintptr_t ext_vec_addrs_ro_input_len;
  const Address<F> *ext_vec_addrs_alpha_pow_output_ptr;
  uintptr_t ext_vec_addrs_alpha_pow_output_len;
  const Address<F> *ext_vec_addrs_ro_output_ptr;
  uintptr_t ext_vec_addrs_ro_output_len;
  const F *alpha_pow_mults_ptr;
  uintptr_t alpha_pow_mults_len;
  const F *ro_mults_ptr;
  uintptr_t ro_mults_len;
};

/// The preprocessed columns for a FRI fold invocation.
template<typename T>
struct FriFoldPreprocessedCols {
  T is_first;
  MemoryAccessColsChips<T> z_mem;
  MemoryAccessColsChips<T> alpha_mem;
  MemoryAccessColsChips<T> x_mem;
  MemoryAccessColsChips<T> alpha_pow_input_mem;
  MemoryAccessColsChips<T> ro_input_mem;
  MemoryAccessColsChips<T> p_at_x_mem;
  MemoryAccessColsChips<T> p_at_z_mem;
  MemoryAccessColsChips<T> ro_output_mem;
  MemoryAccessColsChips<T> alpha_pow_output_mem;
  T is_real;
};

/// An array of four bytes to represent a 32-bit value.
///
/// We use the generic type `T` to represent the different representations of a byte, ranging from
/// a `u8` to a `AB::Var` or `AB::Expr`.
template<typename T>
struct Word {
  T _0[WORD_SIZE];
};

/// A septic extension with an irreducible polynomial `z^7 - 2z - 5`.
///
/// The field can be constructed as `F_{p^7} = F_p[z]/(z^7 - 2z - 5)`.
template<typename F>
struct SepticExtension {
  F _0[7];
};

/// A septic elliptic curve point on y^2 = x^3 + 2x + 26z^5 over field `F_{p^7} = F_p[z]/(z^7 - 2z - 5)`.
template<typename F>
struct SepticCurve {
  /// The x-coordinate of an elliptic curve point.
  SepticExtension<F> x;
  /// The y-coordinate of an elliptic curve point.
  SepticExtension<F> y;
};

/// A global cumulative sum digest, a point on the elliptic curve that `SepticCurve<F>` represents.
/// As these digests start with the `CURVE_CUMULATIVE_SUM_START` point, they require special summing logic.
template<typename F>
struct SepticDigest {
  SepticCurve<F> _0;
};

/// The PublicValues struct is used to store all of a reduce proof's public values.
template<typename T>
struct RecursionPublicValues {
  /// The hash of all the bytes that the program has written to public values.
  Word<T> committed_value_digest[PV_DIGEST_NUM_WORDS];
  /// The hash of all deferred proofs that have been witnessed in the VM.
  T deferred_proofs_digest[POSEIDON_NUM_WORDS];
  /// The start pc of shards being proven.
  T start_pc;
  /// The expected start pc for the next shard.
  T next_pc;
  /// First shard being proven.
  T start_shard;
  /// Next shard that should be proven.
  T next_shard;
  /// First execution shard being proven.
  T start_execution_shard;
  /// Next execution shard that should be proven.
  T next_execution_shard;
  /// Previous MemoryInit address bits.
  T previous_init_addr_bits[32];
  /// Last MemoryInit address bits.
  T last_init_addr_bits[32];
  /// Previous MemoryFinalize address bits.
  T previous_finalize_addr_bits[32];
  /// Last MemoryFinalize address bits.
  T last_finalize_addr_bits[32];
  /// Start state of reconstruct_deferred_digest.
  T start_reconstruct_deferred_digest[POSEIDON_NUM_WORDS];
  /// End state of reconstruct_deferred_digest.
  T end_reconstruct_deferred_digest[POSEIDON_NUM_WORDS];
  /// The commitment to the sp1 program being proven.
  T sp1_vk_digest[DIGEST_SIZE];
  /// The root of the vk merkle tree.
  T vk_root[DIGEST_SIZE];
  /// Current cumulative sum of lookup bus. Note that for recursive proofs for core proofs, this
  /// contains the global cumulative sum.
  SepticDigest<T> global_cumulative_sum;
  /// Whether the proof completely proves the program execution.
  T is_complete;
  /// Whether the proof represents a collection of shards which contain at least one execution
  /// shard, i.e. a shard that contains the `cpu` chip.
  T contains_execution_shard;
  /// The exit code of the program.
  T exit_code;
  /// The digest of all the previous public values elements.
  T digest[DIGEST_SIZE];
};

/// The event for committing to the public values.
template<typename F>
struct CommitPublicValuesEvent {
  RecursionPublicValues<F> public_values;
};

/// The cols for a CommitPVHash invocation.
template<typename T>
struct PublicValuesCols {
  T pv_element;
};

/// An instruction that will save the public values to the execution record and will commit to
/// it's digest.
template<typename F>
struct CommitPublicValuesInstr {
  RecursionPublicValues<Address<F>> pv_addrs;
};

/// The preprocessed columns for the CommitPVHash instruction.
template<typename T>
struct PublicValuesPreprocessedCols {
  T pv_idx[DIGEST_SIZE];
  MemoryAccessColsChips<T> pv_mem;
};

/// The inputs and outputs to a select operation.
template<typename V>
struct SelectIo {
  V bit;
  V out1;
  V out2;
  V in1;
  V in2;
};

/// The event encoding the inputs and outputs of a select operation.
template<typename F>
using SelectEvent = SelectIo<F>;

template<typename F>
struct SelectCols {
  SelectIo<F> vals;
};

/// An instruction invoking the select operation.
template<typename F>
struct SelectInstr {
  SelectIo<Address<F>> addrs;
  F mult1;
  F mult2;
};

template<typename F>
struct SelectPreprocessedCols {
  F is_real;
  SelectIo<Address<F>> addrs;
  F mult1;
  F mult2;
};

/// The inputs and outputs to a Poseidon2 permutation.
template<typename V>
struct Poseidon2Io {
  V input[WIDTH];
  V output[WIDTH];
};

template<typename F>
using Poseidon2Event = Poseidon2Io<F>;

/// Struct for the poseidon2 skinny non preprocessed column.
template<typename T>
struct Poseidon2 {
  T state_var[WIDTH];
  T internal_rounds_s0[NUM_INTERNAL_ROUNDS_S0];
};

/// An instruction invoking the Poseidon2 permutation.
template<typename F>
struct Poseidon2SkinnyInstr {
  Poseidon2Io<Address<F>> addrs;
  F mults[WIDTH];
};

template<typename F>
using Poseidon2Instr = Poseidon2SkinnyInstr<F>;

template<typename T>
struct RoundCountersPreprocessedCols {
  T is_input_round;
  T is_external_round;
  T is_internal_round;
  T round_constants[WIDTH];
};

template<typename T>
struct Poseidon2PreprocessedColsSkinny {
  MemoryAccessColsChips<T> memory_preprocessed[WIDTH];
  RoundCountersPreprocessedCols<T> round_counters_preprocessed;
};

/// A column layout for the preprocessed Poseidon2 AIR.
template<typename T>
struct Poseidon2PreprocessedColsWide {
  Address<T> input[WIDTH];
  MemoryAccessColsChips<T> output[WIDTH];
  T is_real_neg;
};

template<typename F>
using BaseAluEvent = BaseAluIo<F>;

template<typename F>
using ExtAluEvent = ExtAluIo<Block<F>>;











constexpr static const BabyBearP3 MONTY_INVERSE = 1;



extern "C" {

extern void alu_base_event_to_row_babybear(const BaseAluIo<BabyBearP3> *io,
                                           BaseAluValueCols<BabyBearP3> *cols);

extern void alu_base_instr_to_row_babybear(const BaseAluInstr<BabyBearP3> *instr,
                                           BaseAluAccessCols<BabyBearP3> *cols);

extern void alu_ext_event_to_row_babybear(const ExtAluIo<Block<BabyBearP3>> *io,
                                          ExtAluValueCols<BabyBearP3> *cols);

extern void alu_ext_instr_to_row_babybear(const ExtAluInstr<BabyBearP3> *instr,
                                          ExtAluAccessCols<BabyBearP3> *cols);

extern void batch_fri_event_to_row_babybear(const BatchFRIEvent<BabyBearP3> *io,
                                            BatchFRICols<BabyBearP3> *cols);

extern void batch_fri_instr_to_row_babybear(const BatchFRIInstrFFI<BabyBearP3> *instr,
                                            BatchFRIPreprocessedCols<BabyBearP3> *cols,
                                            uintptr_t index);

extern void exp_reverse_bits_event_to_row_babybear(const ExpReverseBitsEventFFI<BabyBearP3> *io,
                                                   uintptr_t i,
                                                   ExpReverseBitsLenCols<BabyBearP3> *cols);

extern void exp_reverse_bits_instr_to_row_babybear(const ExpReverseBitsInstrFFI<BabyBearP3> *instr,
                                                   uintptr_t i,
                                                   uintptr_t len,
                                                   ExpReverseBitsLenPreprocessedCols<BabyBearP3> *cols);

extern void fri_fold_event_to_row_babybear(const FriFoldEvent<BabyBearP3> *io,
                                           FriFoldCols<BabyBearP3> *cols);

extern void fri_fold_instr_to_row_babybear(const FriFoldInstrFFI<BabyBearP3> *instr,
                                           uintptr_t i,
                                           FriFoldPreprocessedCols<BabyBearP3> *cols);

extern void public_values_event_to_row_babybear(const CommitPublicValuesEvent<BabyBearP3> *io,
                                                uintptr_t digest_idx,
                                                PublicValuesCols<BabyBearP3> *cols);

extern void public_values_instr_to_row_babybear(const CommitPublicValuesInstr<BabyBearP3> *instr,
                                                uintptr_t digest_idx,
                                                PublicValuesPreprocessedCols<BabyBearP3> *cols);

extern void select_event_to_row_babybear(const SelectEvent<BabyBearP3> *io,
                                         SelectCols<BabyBearP3> *cols);

extern void select_instr_to_row_babybear(const SelectInstr<BabyBearP3> *instr,
                                         SelectPreprocessedCols<BabyBearP3> *cols);

extern void poseidon2_skinny_event_to_row_babybear(const Poseidon2Event<BabyBearP3> *io,
                                                   Poseidon2<BabyBearP3> *cols);

extern void poseidon2_skinny_instr_to_row_babybear(const Poseidon2Instr<BabyBearP3> *instr,
                                                   uintptr_t i,
                                                   Poseidon2PreprocessedColsSkinny<BabyBearP3> *cols);

extern void poseidon2_wide_event_to_row_babybear(const BabyBearP3 *input,
                                                 BabyBearP3 *input_row,
                                                 bool sbox_state);

extern void poseidon2_wide_instr_to_row_babybear(const Poseidon2Instr<BabyBearP3> *instr,
                                                 Poseidon2PreprocessedColsWide<BabyBearP3> *cols);

}  // extern "C"

}  // namespace sp1_recursion_core_sys
