#pragma once

/* Automatically generated by `cbindgen`. Not intended for manual editing. */

#include <cstdint>

namespace sp1_core_machine_sys {

/// The number of bits in a byte.
constexpr static const uintptr_t BYTE_SIZE = 8;

/// The number of different byte operations.
constexpr static const uintptr_t NUM_BYTE_OPS = 9;

constexpr static const uintptr_t NUM_ROWS = (1 << 16);

/// The maximum log degree of the CPU chip to avoid lookup multiplicity overflow.
constexpr static const uintptr_t MAX_CPU_LOG_DEGREE = 22;

constexpr static const uintptr_t GLOBAL_INITIAL_DIGEST_POS_COPY = 377;

constexpr static const uintptr_t NUM_LOCAL_MEMORY_ENTRIES_PER_ROW = 4;

/// The width of the permutation.
constexpr static const uintptr_t WIDTH = 16;

/// The rate of the permutation.
constexpr static const uintptr_t RATE = (WIDTH / 2);

/// The number of external rounds.
constexpr static const uintptr_t NUM_EXTERNAL_ROUNDS = 8;

/// The number of internal rounds.
constexpr static const uintptr_t NUM_INTERNAL_ROUNDS = 13;

/// The total number of rounds.
constexpr static const uintptr_t NUM_ROUNDS = (NUM_EXTERNAL_ROUNDS + NUM_INTERNAL_ROUNDS);

constexpr static const uintptr_t GHOST = (NUM_INTERNAL_ROUNDS - 1);

/// The maximum log number of shards in core.
constexpr static const uintptr_t MAX_LOG_NUMBER_OF_SHARDS = 16;

/// The maximum number of shards in core.
constexpr static const uintptr_t MAX_NUMBER_OF_SHARDS = (1 << MAX_LOG_NUMBER_OF_SHARDS);

constexpr static const uintptr_t STATE_SIZE = 25;

constexpr static const uintptr_t STATE_NUM_WORDS = (STATE_SIZE * 2);

/// The maximum size of the memory in bytes.
constexpr static const uint32_t MAXIMUM_MEMORY_SIZE = UINT32_MAX;

/// The size of a word in bytes.
constexpr static const uintptr_t WORD_SIZE = 4;

/// The number of bytes necessary to represent a 64-bit integer.
constexpr static const uintptr_t LONG_WORD_SIZE = (2 * WORD_SIZE);

/// The Baby Bear prime.
constexpr static const uint32_t BABYBEAR_PRIME = 2013265921;

/// The minimum file descriptor.
///
/// Any file descriptor must be greater than this value, otherwise the executor will panic.
///
/// This is useful for deprecating file descriptors.
constexpr static const uint32_t LOWEST_ALLOWED_FD = 10;

/// The number of 32 bit words in the SP1 proof's committed value digest.
constexpr static const uintptr_t PV_DIGEST_NUM_WORDS = 8;

/// The number of field elements in the poseidon2 digest.
constexpr static const uintptr_t POSEIDON_NUM_WORDS = 8;

constexpr static const uintptr_t DIGEST_SIZE = 8;

/// The maximum number of elements that can be stored in the public values vec.  Both SP1 and
/// recursive proofs need to pad their public values vec to this length.  This is required since the
/// recursion verification program expects the public values vec to be fixed length.
constexpr static const uintptr_t PROOF_MAX_NUM_PVS = 231;

/// An opcode (short for "operation code") specifies the operation to be performed by the processor.
///
/// In the context of the RISC-V ISA, an opcode specifies which operation (i.e., addition,
/// subtraction, multiplication, etc.) to perform on up to three operands such as registers,
/// immediates, or memory addresses.
///
/// While the SP1 zkVM targets the RISC-V ISA, it uses a custom instruction encoding that uses
/// a different set of opcodes. The main difference is that the SP1 zkVM encodes register
/// operations and immediate operations as the same opcode. For example, the RISC-V opcodes ADD and
/// ADDI both become ADD inside the SP1 zkVM. We utilize flags inside the instruction itself to
/// distinguish between the two.
///
/// Refer to the "RV32I Reference Card" [here](https://github.com/johnwinans/rvalp/releases) for
/// more details.
enum class Opcode : uint8_t {
  /// rd ← rs1 + rs2, pc ← pc + 4
  ADD = 0,
  /// rd ← rs1 - rs2, pc ← pc + 4
  SUB = 1,
  /// rd ← rs1 ^ rs2, pc ← pc + 4
  XOR = 2,
  /// rd ← rs1 | rs2, pc ← pc + 4
  OR = 3,
  /// rd ← rs1 & rs2, pc ← pc + 4
  AND = 4,
  /// rd ← rs1 << rs2, pc ← pc + 4
  SLL = 5,
  /// rd ← rs1 >> rs2 (logical), pc ← pc + 4
  SRL = 6,
  /// rd ← rs1 >> rs2 (arithmetic), pc ← pc + 4
  SRA = 7,
  /// rd ← (rs1 < rs2) ? 1 : 0 (signed), pc ← pc + 4
  SLT = 8,
  /// rd ← (rs1 < rs2) ? 1 : 0 (unsigned), pc ← pc + 4
  SLTU = 9,
  /// rd ← rs1 * rs2 (signed), pc ← pc + 4
  MUL = 10,
  /// rd ← rs1 * rs2 (half), pc ← pc + 4
  MULH = 11,
  /// rd ← rs1 * rs2 (half unsigned), pc ← pc + 4
  MULHU = 12,
  /// rd ← rs1 * rs2 (half signed unsigned), pc ← pc + 4
  MULHSU = 13,
  /// rd ← rs1 / rs2 (signed), pc ← pc + 4
  DIV = 14,
  /// rd ← rs1 / rs2 (unsigned), pc ← pc + 4
  DIVU = 15,
  /// rd ← rs1 % rs2 (signed), pc ← pc + 4
  REM = 16,
  /// rd ← rs1 % rs2 (unsigned), pc ← pc + 4
  REMU = 17,
  /// rd ← sx(m8(rs1 + imm)), pc ← pc + 4
  LB = 18,
  /// rd ← sx(m16(rs1 + imm)), pc ← pc + 4
  LH = 19,
  /// rd ← sx(m32(rs1 + imm)), pc ← pc + 4
  LW = 20,
  /// rd ← zx(m8(rs1 + imm)), pc ← pc + 4
  LBU = 21,
  /// rd ← zx(m16(rs1 + imm)), pc ← pc + 4
  LHU = 22,
  /// m8(rs1 + imm) ← rs2[7:0], pc ← pc + 4
  SB = 23,
  /// m16(rs1 + imm) ← rs2[15:0], pc ← pc + 4
  SH = 24,
  /// m32(rs1 + imm) ← rs2[31:0], pc ← pc + 4
  SW = 25,
  /// pc ← pc + ((rs1 == rs2) ? imm : 4)
  BEQ = 26,
  /// pc ← pc + ((rs1 != rs2) ? imm : 4)
  BNE = 27,
  /// pc ← pc + ((rs1 < rs2) ? imm : 4) (signed)
  BLT = 28,
  /// pc ← pc + ((rs1 >= rs2) ? imm : 4) (signed)
  BGE = 29,
  /// pc ← pc + ((rs1 < rs2) ? imm : 4) (unsigned)
  BLTU = 30,
  /// pc ← pc + ((rs1 >= rs2) ? imm : 4) (unsigned)
  BGEU = 31,
  /// rd ← pc + 4, pc ← pc + imm
  JAL = 32,
  /// rd ← pc + 4, pc ← (rs1 + imm) & ∼1
  JALR = 33,
  /// rd ← pc + imm, pc ← pc + 4
  AUIPC = 34,
  /// Transfer control to the operating system.
  ECALL = 35,
  /// Transfer control to the debugger.
  EBREAK = 36,
  /// Unimplemented instruction.
  UNIMP = 37,
};

/// System Calls.
///
/// A system call is invoked by the the `ecall` instruction with a specific value in register t0.
/// The syscall number is a 32-bit integer with the following little-endian layout:
///
/// | Byte 0 | Byte 1 | Byte 2 | Byte 3 |
/// | ------ | ------ | ------ | ------ |
/// |   ID   | Table  | Cycles | Unused |
///
/// where:
/// - Byte 0: The system call identifier.
/// - Byte 1: Whether the handler of the system call has its own table. This is used in the CPU
///   table to determine whether to lookup the syscall using the syscall interaction.
/// - Byte 2: The number of additional cycles the syscall uses. This is used to make sure the # of
///   memory accesses is bounded.
/// - Byte 3: Currently unused.
enum class SyscallCode : uint32_t {
  /// Halts the program.
  HALT = 0,
  /// Write to the output buffer.
  WRITE = 2,
  /// Enter unconstrained block.
  ENTER_UNCONSTRAINED = 3,
  /// Exit unconstrained block.
  EXIT_UNCONSTRAINED = 4,
  /// Executes the `SHA_EXTEND` precompile.
  SHA_EXTEND = 3145989,
  /// Executes the `SHA_COMPRESS` precompile.
  SHA_COMPRESS = 65798,
  /// Executes the `ED_ADD` precompile.
  ED_ADD = 65799,
  /// Executes the `ED_DECOMPRESS` precompile.
  ED_DECOMPRESS = 264,
  /// Executes the `KECCAK_PERMUTE` precompile.
  KECCAK_PERMUTE = 65801,
  /// Executes the `SECP256K1_ADD` precompile.
  SECP256K1_ADD = 65802,
  /// Executes the `SECP256K1_DOUBLE` precompile.
  SECP256K1_DOUBLE = 267,
  /// Executes the `SECP256K1_DECOMPRESS` precompile.
  SECP256K1_DECOMPRESS = 268,
  /// Executes the `BN254_ADD` precompile.
  BN254_ADD = 65806,
  /// Executes the `BN254_DOUBLE` precompile.
  BN254_DOUBLE = 271,
  /// Executes the `COMMIT` precompile.
  COMMIT = 16,
  /// Executes the `COMMIT_DEFERRED_PROOFS` precompile.
  COMMIT_DEFERRED_PROOFS = 26,
  /// Executes the `VERIFY_SP1_PROOF` precompile.
  VERIFY_SP1_PROOF = 27,
  /// Executes the `BLS12381_DECOMPRESS` precompile.
  BLS12381_DECOMPRESS = 284,
  /// Executes the `HINT_LEN` precompile.
  HINT_LEN = 240,
  /// Executes the `HINT_READ` precompile.
  HINT_READ = 241,
  /// Executes the `UINT256_MUL` precompile.
  UINT256_MUL = 65821,
  /// Executes the `U256XU2048_MUL` precompile.
  U256XU2048_MUL = 65839,
  /// Executes the `BLS12381_ADD` precompile.
  BLS12381_ADD = 65822,
  /// Executes the `BLS12381_DOUBLE` precompile.
  BLS12381_DOUBLE = 287,
  /// Executes the `BLS12381_FP_ADD` precompile.
  BLS12381_FP_ADD = 65824,
  /// Executes the `BLS12381_FP_SUB` precompile.
  BLS12381_FP_SUB = 65825,
  /// Executes the `BLS12381_FP_MUL` precompile.
  BLS12381_FP_MUL = 65826,
  /// Executes the `BLS12381_FP2_ADD` precompile.
  BLS12381_FP2_ADD = 65827,
  /// Executes the `BLS12381_FP2_SUB` precompile.
  BLS12381_FP2_SUB = 65828,
  /// Executes the `BLS12381_FP2_MUL` precompile.
  BLS12381_FP2_MUL = 65829,
  /// Executes the `BN254_FP_ADD` precompile.
  BN254_FP_ADD = 65830,
  /// Executes the `BN254_FP_SUB` precompile.
  BN254_FP_SUB = 65831,
  /// Executes the `BN254_FP_MUL` precompile.
  BN254_FP_MUL = 65832,
  /// Executes the `BN254_FP2_ADD` precompile.
  BN254_FP2_ADD = 65833,
  /// Executes the `BN254_FP2_SUB` precompile.
  BN254_FP2_SUB = 65834,
  /// Executes the `BN254_FP2_MUL` precompile.
  BN254_FP2_MUL = 65835,
  /// Executes the `SECP256R1_ADD` precompile.
  SECP256R1_ADD = 65836,
  /// Executes the `SECP256R1_DOUBLE` precompile.
  SECP256R1_DOUBLE = 301,
  /// Executes the `SECP256R1_DECOMPRESS` precompile.
  SECP256R1_DECOMPRESS = 302,
};

/// Alu Instruction Event.
///
/// This object encapsulated the information needed to prove a RISC-V ALU operation.
struct AluEvent {
  /// The program counter.
  uint32_t pc;
  /// The opcode.
  Opcode opcode;
  /// The first operand value.
  uint32_t a;
  /// The second operand value.
  uint32_t b;
  /// The third operand value.
  uint32_t c;
  /// Whether the first operand is register 0.
  bool op_a_0;
};

/// The prime field `2^31 - 2^27 + 1`, a.k.a. the Baby Bear field.
using BabyBearP3 = uint32_t;

/// An array of four bytes to represent a 32-bit value.
///
/// We use the generic type `T` to represent the different representations of a byte, ranging from
/// a `u8` to a `AB::Var` or `AB::Expr`.
template<typename T>
struct Word {
  T _0[WORD_SIZE];
};

/// A set of columns needed to compute the add of two words.
template<typename T>
struct AddOperation {
  /// The result of `a + b`.
  Word<T> value;
  /// Trace.
  T carry[3];
};

/// The column layout for the chip.
template<typename T>
struct AddSubCols {
  /// The program counter.
  T pc;
  /// Instance of `AddOperation` to handle addition logic in `AddSubChip`'s ALU operations.
  /// It's result will be `a` for the add operation and `b` for the sub operation.
  AddOperation<T> add_operation;
  /// The first input operand.  This will be `b` for add operations and `a` for sub operations.
  Word<T> operand_1;
  /// The second input operand.  This will be `c` for both operations.
  Word<T> operand_2;
  /// Whether the first operand is not register 0.
  T op_a_not_0;
  /// Boolean to indicate whether the row is for an add operation.
  T is_add;
  /// Boolean to indicate whether the row is for a sub operation.
  T is_sub;
};

/// The column layout for the chip.
template<typename T>
struct MulCols {
  /// The program counter.
  T pc;
  /// The output operand.
  Word<T> a;
  /// The first input operand.
  Word<T> b;
  /// The second input operand.
  Word<T> c;
  /// Flag indicating whether `a` is not register 0.
  T op_a_not_0;
  /// Trace.
  T carry[LONG_WORD_SIZE];
  /// An array storing the product of `b * c` after the carry propagation.
  T product[LONG_WORD_SIZE];
  /// The most significant bit of `b`.
  T b_msb;
  /// The most significant bit of `c`.
  T c_msb;
  /// The sign extension of `b`.
  T b_sign_extend;
  /// The sign extension of `c`.
  T c_sign_extend;
  /// Flag indicating whether the opcode is `MUL` (`u32 x u32`).
  T is_mul;
  /// Flag indicating whether the opcode is `MULH` (`i32 x i32`, upper half).
  T is_mulh;
  /// Flag indicating whether the opcode is `MULHU` (`u32 x u32`, upper half).
  T is_mulhu;
  /// Flag indicating whether the opcode is `MULHSU` (`i32 x u32`, upper half).
  T is_mulhsu;
  /// Selector to know whether this row is enabled.
  T is_real;
};

/// The column layout for the chip.
template<typename T>
struct BitwiseCols {
  /// The program counter.
  T pc;
  /// The output operand.
  Word<T> a;
  /// The first input operand.
  Word<T> b;
  /// The second input operand.
  Word<T> c;
  /// Whether the first operand is not register 0.
  T op_a_not_0;
  /// If the opcode is XOR.
  T is_xor;
  T is_or;
  /// If the opcode is AND.
  T is_and;
};

/// The column layout for the chip.
template<typename T>
struct LtCols {
  /// The program counter.
  T pc;
  /// If the opcode is SLT.
  T is_slt;
  /// If the opcode is SLTU.
  T is_sltu;
  /// The output operand.
  T a;
  /// The first input operand.
  Word<T> b;
  /// The second input operand.
  Word<T> c;
  /// Whether the first operand is not register 0.
  T op_a_not_0;
  /// Boolean flag to indicate which byte pair differs if the operands are not equal.
  T byte_flags[4];
  /// The masking b\[3\] & 0x7F.
  T b_masked;
  /// The masking c\[3\] & 0x7F.
  T c_masked;
  /// An inverse of differing byte if c_comp != b_comp.
  T not_eq_inv;
  /// The most significant bit of operand b.
  T msb_b;
  /// The most significant bit of operand c.
  T msb_c;
  /// The multiplication msb_b * is_slt.
  T bit_b;
  /// The multiplication msb_c * is_slt.
  T bit_c;
  /// The result of the intermediate SLTU operation `b_comp < c_comp`.
  T sltu;
  /// A bollean flag for an intermediate comparison.
  T is_comp_eq;
  /// A boolean flag for comparing the sign bits.
  T is_sign_eq;
  /// The comparison bytes to be looked up.
  T comparison_bytes[2];
  /// Boolean fags to indicate which byte differs between the perands `b_comp`, `c_comp`.
  T byte_equality_check[4];
};

/// The column layout for the chip.
template<typename T>
struct ShiftLeftCols {
  /// The program counter.
  T pc;
  /// The output operand.
  Word<T> a;
  /// The first input operand.
  Word<T> b;
  /// The second input operand.
  Word<T> c;
  /// Flag indicating whether `a` is not register 0.
  T op_a_not_0;
  /// The least significant byte of `c`. Used to verify `shift_by_n_bits` and `shift_by_n_bytes`.
  T c_least_sig_byte[BYTE_SIZE];
  /// A boolean array whose `i`th element indicates whether `num_bits_to_shift = i`.
  T shift_by_n_bits[BYTE_SIZE];
  /// The number to multiply to shift `b` by `num_bits_to_shift`. (i.e., `2^num_bits_to_shift`)
  T bit_shift_multiplier;
  /// The result of multiplying `b` by `bit_shift_multiplier`.
  T bit_shift_result[WORD_SIZE];
  /// The carry propagated when multiplying `b` by `bit_shift_multiplier`.
  T bit_shift_result_carry[WORD_SIZE];
  /// A boolean array whose `i`th element indicates whether `num_bytes_to_shift = i`.
  T shift_by_n_bytes[WORD_SIZE];
  T is_real;
};

/// The column layout for the chip.
template<typename T>
struct ShiftRightCols {
  /// The program counter.
  T pc;
  /// The output operand.
  Word<T> a;
  /// The first input operand.
  Word<T> b;
  /// The second input operand.
  Word<T> c;
  /// Flag indicating whether `a` is not register 0.
  T op_a_not_0;
  /// A boolean array whose `i`th element indicates whether `num_bits_to_shift = i`.
  T shift_by_n_bits[BYTE_SIZE];
  /// A boolean array whose `i`th element indicates whether `num_bytes_to_shift = i`.
  T shift_by_n_bytes[WORD_SIZE];
  /// The result of "byte-shifting" the input operand `b` by `num_bytes_to_shift`.
  T byte_shift_result[LONG_WORD_SIZE];
  /// The result of "bit-shifting" the byte-shifted input by `num_bits_to_shift`.
  T bit_shift_result[LONG_WORD_SIZE];
  /// The carry output of `shrcarry` on each byte of `byte_shift_result`.
  T shr_carry_output_carry[LONG_WORD_SIZE];
  /// The shift byte output of `shrcarry` on each byte of `byte_shift_result`.
  T shr_carry_output_shifted_byte[LONG_WORD_SIZE];
  /// The most significant bit of `b`.
  T b_msb;
  /// The least significant byte of `c`. Used to verify `shift_by_n_bits` and `shift_by_n_bytes`.
  T c_least_sig_byte[BYTE_SIZE];
  /// If the opcode is SRL.
  T is_srl;
  /// If the opcode is SRA.
  T is_sra;
  /// Selector to know whether this row is enabled.
  T is_real;
};

/// Memory Record.
///
/// This object encapsulates the information needed to prove a memory access operation. This
/// includes the shard, timestamp, and value of the memory address.
struct MemoryRecord {
  /// The shard number.
  uint32_t shard;
  /// The timestamp.
  uint32_t timestamp;
  /// The value.
  uint32_t value;
};

/// Memory Local Event.
///
/// This object encapsulates the information needed to prove a memory access operation within a
/// shard. This includes the address, initial memory access, and final memory access within a
/// shard.
struct MemoryLocalEvent {
  /// The address.
  uint32_t addr;
  /// The initial memory access.
  MemoryRecord initial_mem_access;
  /// The final memory access.
  MemoryRecord final_mem_access;
};

template<typename T>
struct SingleMemoryLocal {
  /// The address of the memory access.
  T addr;
  /// The initial shard of the memory access.
  T initial_shard;
  /// The final shard of the memory access.
  T final_shard;
  /// The initial clk of the memory access.
  T initial_clk;
  /// The final clk of the memory access.
  T final_clk;
  /// The initial value of the memory access.
  Word<T> initial_value;
  /// The final value of the memory access.
  Word<T> final_value;
  /// Whether the memory access is a real access.
  T is_real;
};

/// Memory Initialize/Finalize Event.
///
/// This object encapsulates the information needed to prove a memory initialize or finalize
/// operation. This includes the address, value, shard, timestamp, and whether the memory is
/// initialized or finalized.
struct MemoryInitializeFinalizeEvent {
  /// The address.
  uint32_t addr;
  /// The value.
  uint32_t value;
  /// The shard number.
  uint32_t shard;
  /// The timestamp.
  uint32_t timestamp;
  /// The used flag.
  uint32_t used;
};

/// Operation columns for verifying that an element is within the range `[0, modulus)`.
template<typename T, uintptr_t N>
struct AssertLtColsBits {
  /// Boolean flags to indicate the first byte in which the element is smaller than the modulus.
  T bit_flags[N];
};

template<typename T>
struct BabyBearBitDecomposition {
  /// The bit decoposition of the`value`.
  T bits[32];
  /// The product of the the bits 3 to 5 in `most_sig_byte_decomp`.
  T and_most_sig_byte_decomp_3_to_5;
  /// The product of the the bits 3 to 6 in `most_sig_byte_decomp`.
  T and_most_sig_byte_decomp_3_to_6;
  /// The product of the the bits 3 to 7 in `most_sig_byte_decomp`.
  T and_most_sig_byte_decomp_3_to_7;
};

/// A set of columns needed to compute whether the given word is 0.
template<typename T>
struct IsZeroOperation {
  /// The inverse of the input.
  T inverse;
  /// Result indicating whether the input is 0. This equals `inverse * input == 0`.
  T result;
};

template<typename T>
struct MemoryInitCols {
  /// The shard number of the memory access.
  T shard;
  /// The timestamp of the memory access.
  T timestamp;
  /// The address of the memory access.
  T addr;
  /// Comparison assertions for address to be strictly increasing.
  AssertLtColsBits<T, 32> lt_cols;
  /// A bit decomposition of `addr`.
  BabyBearBitDecomposition<T> addr_bits;
  /// The value of the memory access.
  T value[32];
  /// Whether the memory access is a real access.
  T is_real;
  /// Whether or not we are making the assertion `addr < addr_next`.
  T is_next_comp;
  /// A witness to assert whether or not we the previous address is zero.
  IsZeroOperation<T> is_prev_addr_zero;
  /// Auxiliary column, equal to `(1 - is_prev_addr_zero.result) * is_first_row`.
  T is_first_comp;
  /// A flag to indicate the last non-padded address. An auxiliary column needed for degree 3.
  T is_last_addr;
};

/// Memory Write Record.
///
/// This object encapsulates the information needed to prove a memory write operation. This
/// includes the value, shard, timestamp, previous value, previous shard, and previous timestamp.
struct MemoryWriteRecord {
  /// The value.
  uint32_t value;
  /// The shard number.
  uint32_t shard;
  /// The timestamp.
  uint32_t timestamp;
  /// The previous value.
  uint32_t prev_value;
  /// The previous shard number.
  uint32_t prev_shard;
  /// The previous timestamp.
  uint32_t prev_timestamp;
};

/// Syscall Event.
///
/// This object encapsulated the information needed to prove a syscall invocation from the CPU
/// table. This includes its shard, clk, syscall id, arguments, other relevant information.
struct SyscallEvent {
  /// The program counter.
  uint32_t pc;
  /// The next program counter.
  uint32_t next_pc;
  /// The shard number.
  uint32_t shard;
  /// The clock cycle.
  uint32_t clk;
  /// The `op_a` memory write record.
  MemoryWriteRecord a_record;
  /// Whether the `op_a` memory write record is real.
  bool a_record_is_real;
  /// Whether the first operand is register 0.
  bool op_a_0;
  /// The syscall code.
  SyscallCode syscall_code;
  /// The syscall id.
  uint32_t syscall_id;
  /// The first operand value (`op_b`).
  uint32_t arg1;
  /// The second operand value (`op_c`).
  uint32_t arg2;
};

/// The column layout for the chip.
template<typename T>
struct SyscallCols {
  /// The shard number of the syscall.
  T shard;
  /// The clk of the syscall.
  T clk;
  /// The syscall_id of the syscall.
  T syscall_id;
  /// The arg1.
  T arg1;
  /// The arg2.
  T arg2;
  T is_real;
};

/// The column layout for instructions.
template<typename T>
struct InstructionCols {
  /// The opcode for this cycle.
  T opcode;
  /// The first operand for this instruction.
  T op_a;
  /// The second operand for this instruction.
  Word<T> op_b;
  /// The third operand for this instruction.
  Word<T> op_c;
  /// Flags to indicate if op_a is register 0.
  T op_a_0;
  /// Whether op_b is an immediate value.
  T imm_b;
  /// Whether op_c is an immediate value.
  T imm_c;
};

template<typename T>
struct MemoryAccessCols {
  /// The value of the memory access.
  Word<T> value;
  /// The previous shard and timestamp that this memory access is being read from.
  T prev_shard;
  T prev_clk;
  /// This will be true if the current shard == prev_access's shard, else false.
  T compare_clk;
  /// The following columns are decomposed limbs for the difference between the current access's
  /// timestamp and the previous access's timestamp.  Note the actual value of the timestamp
  /// is either the accesses' shard or clk depending on the value of compare_clk.
  ///
  /// This column is the least significant 16 bit limb of current access timestamp - prev access
  /// timestamp.
  T diff_16bit_limb;
  /// This column is the most significant 8 bit limb of current access timestamp - prev access
  /// timestamp.
  T diff_8bit_limb;
};

/// Memory read-write access.
template<typename T>
struct MemoryReadWriteCols {
  Word<T> prev_value;
  MemoryAccessCols<T> access;
};

/// Memory read access.
template<typename T>
struct MemoryReadCols {
  MemoryAccessCols<T> access;
};

/// The column layout for the CPU.
template<typename T>
struct CpuCols {
  /// The current shard.
  T shard;
  /// The least significant 16 bit limb of clk.
  T clk_16bit_limb;
  /// The most significant 8 bit limb of clk.
  T clk_8bit_limb;
  /// The shard to send to the opcode specific tables.  This should be 0 for all instructions other
  /// than the ecall and memory instructions.
  T shard_to_send;
  /// The clk to send to the opcode specific tables.  This should be 0 for all instructions other
  /// than the ecall and memory instructions.
  T clk_to_send;
  /// The program counter value.
  T pc;
  /// The expected next program counter value.
  T next_pc;
  /// Columns related to the instruction.
  InstructionCols<T> instruction;
  /// Whether op_a should not be changed by the instruction.  This should be true for
  /// memory store and branch instructions.
  T op_a_immutable;
  /// Whether this is a memory instruction.
  T is_memory;
  /// Whether this is a syscall instruction.
  T is_syscall;
  /// Whether this is a halt instruction.
  T is_halt;
  /// The number of extra cycles to add to the clk for a syscall instruction.
  T num_extra_cycles;
  /// Operand values, either from registers or immediate values.
  MemoryReadWriteCols<T> op_a_access;
  MemoryReadCols<T> op_b_access;
  MemoryReadCols<T> op_c_access;
  /// Selector to label whether this row is a non padded row.
  T is_real;
};

/// A column layout for the intermediate states of a Poseidon2 AIR across all rounds.
template<typename T>
struct Poseidon2StateCols {
  T external_rounds_state[NUM_EXTERNAL_ROUNDS][WIDTH];
  T internal_rounds_state[WIDTH];
  T internal_rounds_s0[GHOST];
  T output_state[WIDTH];
};

/// A column layout for the intermediate S-box states of a Poseidon2 AIR across all rounds.
template<typename T>
struct Poseidon2SBoxCols {
  T external_rounds_sbox_state[NUM_EXTERNAL_ROUNDS][WIDTH];
  T internal_rounds_sbox_state[NUM_INTERNAL_ROUNDS];
};

/// A column layout for a poseidon2 permutation with degree 3 constraints.
template<typename T>
struct Poseidon2Degree3Cols {
  Poseidon2StateCols<T> state;
  Poseidon2SBoxCols<T> sbox_state;
};

/// A column layout for a poseidon2 permutation with degree 9 constraints.
template<typename T>
struct Poseidon2Degree9Cols {
  Poseidon2StateCols<T> state;
};

/// A septic extension with an irreducible polynomial `z^7 - 2z - 5`.
///
/// The field can be constructed as `F_{p^7} = F_p[z]/(z^7 - 2z - 5)`.
template<typename F>
struct SepticExtension {
  F _0[7];
};

/// A septic elliptic curve point on y^2 = x^3 + 2x + 26z^5 over field `F_{p^7} = F_p[z]/(z^7 - 2z - 5)`.
template<typename F>
struct SepticCurve {
  /// The x-coordinate of an elliptic curve point.
  SepticExtension<F> x;
  /// The y-coordinate of an elliptic curve point.
  SepticExtension<F> y;
};

template<typename T>
struct MemoryLocalCols {
  SingleMemoryLocal<T> memory_local_entries[NUM_LOCAL_MEMORY_ENTRIES_PER_ROW];
};

struct Ghost {
  uintptr_t v[GLOBAL_INITIAL_DIGEST_POS_COPY];
};

/// A block of columns for septic extension.
template<typename T>
struct SepticBlock {
  T _0[7];
};

/// A set of columns needed to compute the Poseidon2 operation.
template<typename T>
struct Poseidon2Operation {
  /// The permutation.
  Poseidon2Degree3Cols<T> permutation;
};

/// A set of columns needed to compute the global interaction elliptic curve digest.
template<typename T>
struct GlobalInteractionOperation {
  T offset_bits[8];
  SepticBlock<T> x_coordinate;
  SepticBlock<T> y_coordinate;
  T y6_bit_decomp[30];
  T range_check_witness;
  Poseidon2Operation<T> permutation;
};

/// Global Interaction Event.
///
/// This event is emitted for all interactions that are sent or received across different shards.
struct GlobalInteractionEvent {
  /// The message.
  uint32_t message[7];
  /// Whether the interaction is received or sent.
  bool is_receive;
  /// The kind of the interaction event.
  uint8_t kind;
};

/// A set of columns needed to compute the global interaction elliptic curve digest.
/// It is critical that this struct is at the end of the main trace, as the permutation constraints will be dependent on this fact.
/// It is also critical the the cumulative sum is at the end of this struct, for the same reason.
template<typename T, uintptr_t N>
struct GlobalAccumulationOperation {
  SepticBlock<T> initial_digest[2];
  SepticBlock<T> sum_checker[N];
  SepticBlock<T> cumulative_sum[N][2];
};

template<typename T>
struct GlobalCols {
  T message[7];
  T kind;
  GlobalInteractionOperation<T> interaction;
  T is_receive;
  T is_send;
  T is_real;
  GlobalAccumulationOperation<T, 1> accumulation;
};































































constexpr static const BabyBearP3 MONTY_INVERSE = 1;



extern "C" {

extern void add_sub_event_to_row_babybear(const AluEvent *event, AddSubCols<BabyBearP3> *cols);

extern void mul_event_to_row_babybear(const AluEvent *event, MulCols<BabyBearP3> *cols);

extern void bitwise_event_to_row_babybear(const AluEvent *event, BitwiseCols<BabyBearP3> *cols);

extern void lt_event_to_row_babybear(const AluEvent *event, LtCols<BabyBearP3> *cols);

extern void sll_event_to_row_babybear(const AluEvent *event, ShiftLeftCols<BabyBearP3> *cols);

extern void sr_event_to_row_babybear(const AluEvent *event, ShiftRightCols<BabyBearP3> *cols);

extern void memory_local_event_to_row_babybear(const MemoryLocalEvent *event,
                                               SingleMemoryLocal<BabyBearP3> *cols);

extern void memory_global_event_to_row_babybear(const MemoryInitializeFinalizeEvent *event,
                                                bool is_receive,
                                                MemoryInitCols<BabyBearP3> *cols);

extern void syscall_event_to_row_babybear(const SyscallEvent *event,
                                          bool is_receive,
                                          SyscallCols<BabyBearP3> *cols);

}  // extern "C"

}  // namespace sp1_core_machine_sys
